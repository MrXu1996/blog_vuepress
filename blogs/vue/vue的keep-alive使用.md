---
title: Vue keep-alive使用
date: 2020-12-25
categories:
 - VUE
tags: 
 - vue基础
---

## Vue keep-alive使用

> 分析: 此题考查Vue中组件缓存的使用 
>
> 解析:  keep-alive是 Vue提供的一个全局组件, Vue的组件是有销毁机制的,比如条件渲染, 路由跳转时 组件都会经历**`销毁`**, 再次回到页面时,又会回到 **`重生`**, 这一过程保证了生命周期钩子函数各个过程都会在这一生命周期中执行.
>
> 但是,我们辛辛苦苦获取的数据 滑动的页面 会因为组件的销毁 重生 而 **`归零`**,这影响了交互的体验, 所以 keep-alvie出现了, 可以帮助我们缓存想要缓存的组件实例, 只用用keep-alive **`包裹`**你想要缓存的组件实例, 这个时候, 组件创建之后,就不会再进行 销毁, 组件数据和状态得以保存
>
> 但是,没有了销毁,也就失去了重生的环节, 我们失去了 原有的钩子函数, 所以keep-alive包裹的组件 都获取了另外**两个事件 --如果缓存组件需要重新获取数据**
>
> 唤醒 activated重新唤醒休眠组件实例时 执行
>
> 休眠 deactivated组件实例进入休眠状态时执行

但是我们不能缓存所有的组件实例, 如果是针对 组件容器 router-view 这个组件进行的缓存, 一般的策略是在路由的元信息 meta对象中设置是否缓存的标记,  然后根据标记决定是否进行缓存

```js
  <div id="app">
    <keep-alive>
      <!-- 里面是当需要缓存时 -->
      <router-view  v-if="$route.meta.isAlive" />
    </keep-alive>
     <!-- 外面是不需要缓存时 -->
    <router-view  v-if="!$route.meta.isAlive" />
  </div>
```

还有需要注意的问题是:  被缓存的组件中如果还有子组件, 那么子组件也会一并拥有 激活和唤醒事件,并且这些事件会在同时执行